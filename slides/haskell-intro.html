<!doctype html>
<html lang="en">
  <head>
	<meta charset="utf-8">

    <title>Duke PL Course</title>

    
    <meta name="description" content="Programming Languages Functional Programming in Haskell Jim Posen - ECE/CS 2014 Functional Programming We saw it with Racket Recall that functional &hellip;">
    
    <meta name="author" content="Yang Su, Kevin Gao">

	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<link rel="stylesheet" href="/vendor/reveal.js-2.5.0/css/reveal.min.css">
	<link rel="stylesheet" href="/vendor/reveal.js-2.5.0/css/theme/beige.css" id="theme">

	<!-- For syntax highlighting -->
	<link rel="stylesheet" href="/vendor/reveal.js-2.5.0/lib/css/zenburn.css">

	<!-- If the query includes 'print-pdf', use the PDF print sheet -->
	<script>
	  document.write( '<link rel="stylesheet" href="/vendor/reveal.js-2.5.0/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
	</script>

	<!--[if lt IE 9]>
	<script src="lib/js/html5shiv.js"></script>
	<![endif]-->

    <link href="/favicon.png" rel="icon">
  </head>

  <body>
	<div class="reveal">
	  <!-- Any section element inside of this container is displayed as a slide -->
	  <div class="slides">
        <section>
  <h1>Programming Languages</h1>
  <h3>Functional Programming in Haskell</h3>
  <small>Jim Posen - ECE/CS 2014</small>
</section>
<section>
  <section>
    <h2>Functional Programming</h2>
    <ul>
      <li>We saw it with Racket</li>
      <li>Recall that functional programs have limited side effects</li>
      <li>
        A side effect is where a function application changes state or has an observable effect
        <ul>
          <li>Modifies a free variable, performs IO, etc</li>
        </ul>
      </li>
    </ul>
  </section>
  <section>
    <p>Side effects</p>
    <pre><code>def fib(n):&#x000A;  x1 = 0&#x000A;  x2 = 1&#x000A;  for i in range(n):&#x000A;    tmp = x2&#x000A;    x2 = x1 + x2&#x000A;    x1 = tmp&#x000A;  return x1&#x000A;</code></pre>
  </section>
  <section>
    <p>No side effects</p>
    <pre><code>(define (fib n)&#x000A;  (if (< n 2)&#x000A;      n&#x000A;      (+ (fib (- n 1)) (fib (- n 2)))))&#x000A;</code></pre>
  </section>
</section>
<section>
  <h3>Functional programming benefits</h3>
  <ul>
    <li>Side effects made it difficult to analyze behavior</li>
    <li>Functions with no side effects can be easily tested</li>
    <li>
      Functions are
      <strong>referentially transparent</strong>
      <ul>
        <li>An expression can be replaced with its value</li>
      </ul>
    </li>
  </ul>
</section>
<section>
  <h2>Haskell</h2>
  <ul>
    <li>
      Haskell is
      <strong>purely functional</strong>
    </li>
    <li>
      High level constructs called
      <strong>monads</strong>
      are used to isolate side effects
    </li>
    <li>This means values are immutable (with one exception)</li>
    <li>Haskell uses lazy evaluation</li>
    <li>Haskell is statically (and strongly) typed</li>
  </ul>
</section>
<section>
  <h2>Running Haskell</h2>
  <ul>
    <li>Haskell is compiled</li>
    <li>GHC compiles to native machine code by default</li>
    <li>GHCi is the interactive environment (REPL)</li>
  </ul>
</section>
<section>
  <h1>Haskell Syntax</h1>
</section>
<section>
  <section>
    <h2>Basic scalar types</h2>
    <ul>
      <li>Numbers</li>
      <li>Chars</li>
      <li>Bools</li>
    </ul>
  </section>
  <section>
    <h3>Numbers</h3>
    <p>Int, Integer, Rational, Float, etc</p>
    <pre><code>ghci> (50 * 100) - 4999&#x000A;1&#x000A;ghci> 50 * 100 - 4999&#x000A;1&#x000A;ghci> 50 * (100 - 4999)&#x000A;-244950&#x000A;</code></pre>
  </section>
  <section>
    <h3>Chars</h3>
    <p>Denoted with singe quotes</p>
  </section>
  <section>
    <h3>Bools</h3>
    <p>
      <code>True</code>
      or
      <code>False</code>
    </p>
  </section>
</section>
<section>
  <h2>Function application</h2>
  <ul>
    <li>Generally uses prefix notation</li>
    <li>Parenthesis are not necessary, but may be helpful</li>
  </ul>
  <pre><code>ghci> min 5 6 + max 10 20&#x000A;25&#x000A;ghci> min 5 max 3 4&#x000A;-- Crash!&#x000A;ghci> min 6 (max 3 4)&#x000A;4&#x000A;</code></pre>
</section>
<section>
  <h2>Function definitions</h2>
  <ul>
    <li>Functions are defined with =</li>
    <li>Functions are defined over some parameters</li>
    <li>0-arity (no parameters) functions can be thought of as constants</li>
    <li>
      <em>
        Must use
        <code>let</code>
        in GHCi
      </em>
    </li>
  </ul>
  <pre><code>ghci> let pi = 3.14&#x000A;ghci> let area r = pi * r ^ 2&#x000A;ghci> area 5&#x000A;78.5&#x000A;ghci> let hypot x y = sqrt (x ^ 2 + y ^ 2)&#x000A;ghci> hypot 3 4&#x000A;5.0&#x000A;</code></pre>
</section>
<section>
  <h2>Let and where</h2>
  <ul>
    <li>Let and where create scoped variables</li>
  </ul>
  <pre><code>area r =&#x000A;    let pi = 3.14&#x000A;    in pi * r ^ 2&#x000A;</code></pre>
  <pre><code>area r = pi * r ^ 2&#x000A;    where pi = 3.14&#x000A;</code></pre>
</section>
<section>
  <section>
    <h2>Lists</h2>
    <ul>
      <li>Lists are linked lists, like in Lisp</li>
      <li>Lists may only contain elements of one type</li>
    </ul>
    <pre><code>ghci> head [1, 2, 3, 4]&#x000A;1&#x000A;ghci> tail [1, 2, 3, 4]&#x000A;[2, 3, 4]&#x000A;</code></pre>
  </section>
  <section>
    <h3>List operations</h3>
    <ul>
      <li>
        <code>head</code>
        is like
        <code>car</code>
      </li>
      <li>
        <code>tail</code>
        is like
        <code>cdr</code>
      </li>
      <li>
        <code>:</code>
        is like
        <code>cons</code>
      </li>
      <li>++ concatenates lists</li>
      <li>!! gets the nth element (zero-indexed)</li>
    </ul>
    <pre><code>ghci> 1:[2, 3, 4]&#x000A;[1, 2, 3, 4]&#x000A;ghci> [1, 2] ++ [3, 4]&#x000A;[1, 2, 3, 4]&#x000A;ghci> [1, 2] ++ [3, 4]&#x000A;[1, 2, 3, 4]&#x000A;ghci> [1, 2, 3, 4] !! 1&#x000A;2&#x000A;</code></pre>
  </section>
</section>
<section>
  <h2>Strings</h2>
  <ul>
    <li>String literals denoted with double quotes</li>
    <li>Strings are lists of chars</li>
    <pre><code>ghci> ['h', 'e', 'l', 'l', 'o'] ++ " world"&#x000A;"hello world"&#x000A;</code></pre>
  </ul>
</section>
<section>
  <section>
    <h2>Ranges</h2>
    <ul>
      <li>Simple syntax for generating ranges using ..</li>
      <li>You can specify a step</li>
    </ul>
    <pre><code>ghci> [1..9]&#x000A;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#x000A;ghci> [1, 3..9]&#x000A;[1, 3, 5, 7, 9]&#x000A;ghci> ['a'..'e']&#x000A;"abcde"&#x000A;</code></pre>
  </section>
  <section>
    <h3>Infinite ranges</h3>
    <ul>
      <li>Ranges can be infinite</li>
      <li>Lazy evaluation makes this possible</li>
    </ul>
    <pre><code>ghci> let evens = [0, 2..]&#x000A;ghci> evens !! 10&#x000A;20&#x000A;</code></pre>
  </section>
</section>
<section>
  <h2>Tuples</h2>
  <ul>
    <li>Collections of elements</li>
    <li>Fixed size</li>
    <li>May contain different elements</li>
  </ul>
  <pre><code>ghci> (1, 'a', [3.0])&#x000A;(1, 'a', [3.0])&#x000A;ghci> zip [1, 2, 3] "abc"&#x000A;[(1, 'a'), (2, 'b'), (3, 'c')]&#x000A;</code></pre>
</section>
<section>
  <section>
    <h2>Conditionals</h2>
    <p>Let&#8217;s define !! recursively</p>
    <pre><code>nth lst n =&#x000A;    if n == 0&#x000A;    then head lst&#x000A;    else nth (tail lst) (n - 1)&#x000A;</code></pre>
  </section>
  <section>
    <p>Woohoo, it looks like Lisp</p>
    <p>But we can do better&#8230;</p>
  </section>
</section>
<section>
  <section>
    <h2>Pattern matching</h2>
    <pre><code>nth lst 0 = head lst&#x000A;nth lst n = nth (tail lst) (n - 1)&#x000A;</code></pre>
  </section>
  <section>
    <p>Ooh, that&#8217;s pretty</p>
    <p>But we can do better&#8230;</p>
  </section>
</section>
<section>
  <section>
    <h3>Even more pattern matching</h3>
    <p>
      <em>Note: _ typically means ignored variable</em>
    </p>
    <pre><code>nth (h:_) 0 = h&#x000A;nth (_:t) n = nth t (n - 1)&#x000A;</code></pre>
  </section>
  <section>
    <p>We can even pattern match tuples</p>
    <pre><code>flipTuple (x, y) = (y, x)&#x000A;</code></pre>
  </section>
</section>
<section>
  <h3>Nifty syntax note</h3>
  <p>Backticks allow infix notation</p>
  <pre><code>ghci> nth [1, 2, 3] 1&#x000A;ghci> [1, 2, 3] `nth` 1&#x000A;</code></pre>
</section>
<section>
  <section>
    <h2>Guards</h2>
    <ul>
      <li>
        Recall the Collatz sequence
        <ul>
          <li>n -> n/2 (n even)</li>
          <li>n -> 3n + 1 (n odd)</li>
          <li>13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1</li>
        </ul>
      </li>
      <li>Can we write collatzNext with pattern matching?</li>
    </ul>
    <pre><code>(define (collatz-next n)&#x000A;  (if (even? n)&#x000A;      (/ n 2)&#x000A;      (+ 1 (* 3 n))))&#x000A;</code></pre>
  </section>
  <section>
    <p>No, but we can use guards</p>
    <pre><code>collatzNext n =&#x000A;    | even n = n / 2&#x000A;    | otherwise = 3 * n + 1&#x000A;</code></pre>
  </section>
</section>
<section>
  <section>
    <h2>List Comprehensions</h2>
    <ul>
      <li>Really nice syntax for transformations on lists</li>
    </ul>
  </section>
  <section>
    <p>Let&#8217;s double all elements in a range</p>
    <p>Lisp</p>
    <pre><code>(map (lambda (x) (* x 2)) (range 1 11))&#x000A;</code></pre>
    <p>Haskell</p>
    <pre><code>[x * 2 | x <- [1..10]]&#x000A;</code></pre>
  </section>
  <section>
    <p>Let&#8217;s double all multiples of 7 less than 100</p>
    <p>Lisp</p>
    <pre><code>(map (lambda (x) (* x 2))&#x000A;     (filter (lambda (x) (zero? (mod x 7)))&#x000A;             (range 1 11)))&#x000A;&#x000A;</code></pre>
    <pre><code>[x * 2 | x <- [1..10], x `mod` 7 == 0]&#x000A;</code></pre>
  </section>
  <section>
    <p>map, filter, and foldl still exist of course</p>
  </section>
</section>

      </div>
    </div>

	<script src="/vendor/reveal.js-2.5.0/lib/js/head.min.js"></script>
	<script src="/vendor/reveal.js-2.5.0/js/reveal.min.js"></script>

	<script>
	  // Full list of configuration options available here:
	  // https://github.com/hakimel/reveal.js#configuration
	  Reveal.initialize({
	  controls: true,
	  progress: true,
	  history: true,
	  center: true,

	  theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
	  transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

	  // Optional libraries used to extend on reveal.js
	  dependencies: [
	  { src: '/vendor/reveal.js-2.5.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
	  { src: '/vendor/reveal.js-2.5.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	  { src: '/vendor/reveal.js-2.5.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	  { src: '/vendor/reveal.js-2.5.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
	  { src: '/vendor/reveal.js-2.5.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
	  { src: '/vendor/reveal.js-2.5.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
	  ]
	  });
	</script>
    
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37844085-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>



  </body>
</html>
